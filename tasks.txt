************
ITERATION 2:
************
Camera follows player:
	Just calculates a simple transformation matrix (code already implemented). Needs to be given to every IView?

Crosshair:
	Takes camera transform into account. Is this just another IView, or is it more complex?

Railgun:
	STEP 1:
	Player clicks somewhere on screen, a line extends from the player to the first intersection with the level.
	STEP 2:
	Client sends fire event to Server. Server calculates all hits, sends fire event to ALL clients (including list of hit players). Clients draw railgun trail and change colour of hit players (since we don't have health/death implemented yet)

Game exit:
	Can exit game without raising an exception. Resources (network sockets) properly disposed?

Console:
	Fills half the screen with black. Can type simple commands. eg. > physics_debug off

Replay system:
	STEP 1:
	We need to investigate what effect Farseer has on this... Apparently it's not deterministic. Way around this? Do player physics manually?
	STEP 2:
	Implementation: Records all input (what? network incoming messages and local input? (if client)). Records a periodic 'summary' of the game state.
	STEP 3:
	Run game simulation from recorded files (instead of live input). Confirm that the game state reaches the expected 'summary' states.


************
ITERATION 1:
************
Player Input:  TERENCE
	Player should be able to move around screen, jump, and (possibly) aim with the mouse.

Player physics: DONE?
	Player collides with level, player motion applied by physics engine

Level:  ZAK
	Level built up out of farseer Body objects. Player collides against level. Level is rendered.

Abstract Drawing Code: 
	Make ISpriteBatch, with methods Draw(.....), then make an XNASpriteBatch : ISpriteBatch, that just wraps SpriteBatch's Draw methods (the one we need for now) and takes a XNA SpriteBatch in its constructor. This way we can unit test all the IViews.
